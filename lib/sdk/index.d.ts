// Generated by dts-bundle-generator v9.5.1

export type PolicyPhase = "pre" | "core" | "post";
export interface PolicyDescriptor {
	/** Name of the policy, used for debugging and introspection */
	name: string;
	/** When the policy should be applied */
	phase?: PolicyPhase;
	/** Optional filter based on log level */
	level?: string[];
	/** Custom filter function */
	filter?: (log: BusEvent) => boolean;
	/** Order of execution relative to other policies */
	priority?: number;
	/**
	 * Core handler function
	 * You must call `next()` to forward the log to the next policy
	 */
	handle: (log: BusEvent, config: typeof BusConfig, next: () => void) => void;
}
declare class MoniTextPolicy {
	readonly descriptor: PolicyDescriptor;
	constructor(descriptor: PolicyDescriptor);
	get name(): string;
	get phase(): PolicyPhase;
	apply(log: any, config: any, next: () => void): void;
	matches(log: any): boolean;
}
declare class StackTraceInfo {
	readonly callerName: string;
	readonly fileName: string;
	readonly lineNumber: string | undefined;
	readonly columnNumber: string | undefined;
	readonly fullTrace: string[];
	/**
	 * @param callerName {string} - Name of the calling function.
	 * @param fileName {string} - The file path or name where the call occurred.
	 * @param lineNumber {string | undefined} - The line number within the file.
	 * @param columnNumber {string | undefined} - The column number within the line.
	 * @param fullTrace {string[]} - The full captured stack trace.
	 */
	constructor(callerName: string, fileName: string, lineNumber: string | undefined, columnNumber: string | undefined, fullTrace: string[]);
}
/**
 * Type alias for instances of StackTraceInfo.
 */
export type StackInfo = InstanceType<typeof StackTraceInfo>;
declare class LookSetup {
	node: number;
	deno: number;
	bun: number;
	browser: number;
	defaults?: number;
	/**
	 * @param config {Object} - Stack depth configuration per environment.
	 * @param config.node {number} - Stack depth for Node.js.
	 * @param config.deno {number} - Stack depth for Deno.
	 * @param config.bun {number} - Stack depth for Bun.
	 * @param config.browser {number} - Stack depth for browser environments.
	 * @param config.defaults {number} - Default fallback depth if environment is unknown.
	 */
	constructor({ node, deno, bun, browser, defaults }: LookSetup);
}
declare function lookUpInStack(at: number | LookSetup | typeof LookSetup): StackTraceInfo | {
	fullTrace: string[];
};
declare abstract class Struct<T extends object> {
	#private;
	_struct: T;
	constructor(raw?: Partial<T>);
	/**
	 * Subclasses must implement validation logic.
	 */
	abstract validate(): void;
	/**
	 * Get deep copy of plain object version of this struct.
	 */
	toObject(): T;
	/**
	 * Clone the struct with overrides.
	 */
	clone(overrides?: Partial<T>): this;
	/**
	 * Patch the current instance in-place.
	 */
	patch(overrides?: Partial<T>): this;
	describe(): Record<string, any>;
	pick<K extends keyof T>(...keys: K[]): Pick<T, K>;
	omit<K extends keyof T>(...keys: K[]): Omit<T, K>;
	pickStruct<K extends keyof T>(...keys: K[]): Struct<Pick<T, K>>;
}
declare function createStructFromShape<S extends object>(shape: S, validateFn?: (this: S & Struct<S>) => void): {
	new (raw?: Partial<S>): {
		validate(): void;
		"__#1@#raw": S;
		_struct: S;
		/**
		 * Get deep copy of plain object version of this struct.
		 */
		toObject(): S;
		/**
		 * Clone the struct with overrides.
		 */
		clone(overrides?: Partial<S>): any;
		/**
		 * Patch the current instance in-place.
		 */
		patch(overrides?: Partial<S>): any;
		describe(): Record<string, any>;
		pick<K extends keyof S>(...keys: K[]): Pick<S, K>;
		omit<K extends keyof S>(...keys: K[]): Omit<S, K>;
		pickStruct<K extends keyof S>(...keys: K[]): Struct<Pick<S, K>>;
	};
};
declare const LogLevels: readonly [
	"info",
	"warn",
	"error",
	"fatal",
	"trace",
	"profile",
	"success",
	"failure"
];
/**
 * Union type representing all valid log levels.
 */
export type LogLevel = typeof LogLevels[number];
declare const LogInstance: {
	new (raw?: Partial<{
		/** Whether this log entry has been processed and finalized */
		ready: boolean;
		/** Primary log level (e.g., "info", "error") */
		level: LogLevel;
		/** Additional log levels applied to this entry (optional) */
		subLevels: LogLevel[];
		/** Arbitrary context object for user metadata (e.g., request ID, tags) */
		context: Record<string, any>;
		/** Log Specific configuration object  */
		config: Record<string, any>;
		/** Log message fragments; to be joined or rendered later */
		message: string[];
		/** Captured stack trace info from the log emitter's callsite */
		meta: StackInfo;
		/** Runtime environment in which the log was created (node, bun, browser...) */
		env: "browser" | "node" | "deno" | "bun" | undefined;
		/** ISO string or timestamp representing log creation time */
		timestamp: string;
		/** Unique symbol to identify this log instance (for deduplication or tracking) */
		identifyer: Symbol;
	}> | undefined): {
		validate(): void;
		"__#1@#raw": {
			/** Whether this log entry has been processed and finalized */
			ready: boolean;
			/** Primary log level (e.g., "info", "error") */
			level: LogLevel;
			/** Additional log levels applied to this entry (optional) */
			subLevels: LogLevel[];
			/** Arbitrary context object for user metadata (e.g., request ID, tags) */
			context: Record<string, any>;
			/** Log Specific configuration object  */
			config: Record<string, any>;
			/** Log message fragments; to be joined or rendered later */
			message: string[];
			/** Captured stack trace info from the log emitter's callsite */
			meta: StackInfo;
			/** Runtime environment in which the log was created (node, bun, browser...) */
			env: "browser" | "node" | "deno" | "bun" | undefined;
			/** ISO string or timestamp representing log creation time */
			timestamp: string;
			/** Unique symbol to identify this log instance (for deduplication or tracking) */
			identifyer: Symbol;
		};
		_struct: {
			/** Whether this log entry has been processed and finalized */
			ready: boolean;
			/** Primary log level (e.g., "info", "error") */
			level: LogLevel;
			/** Additional log levels applied to this entry (optional) */
			subLevels: LogLevel[];
			/** Arbitrary context object for user metadata (e.g., request ID, tags) */
			context: Record<string, any>;
			/** Log Specific configuration object  */
			config: Record<string, any>;
			/** Log message fragments; to be joined or rendered later */
			message: string[];
			/** Captured stack trace info from the log emitter's callsite */
			meta: StackInfo;
			/** Runtime environment in which the log was created (node, bun, browser...) */
			env: "browser" | "node" | "deno" | "bun" | undefined;
			/** ISO string or timestamp representing log creation time */
			timestamp: string;
			/** Unique symbol to identify this log instance (for deduplication or tracking) */
			identifyer: Symbol;
		};
		toObject(): {
			/** Whether this log entry has been processed and finalized */
			ready: boolean;
			/** Primary log level (e.g., "info", "error") */
			level: LogLevel;
			/** Additional log levels applied to this entry (optional) */
			subLevels: LogLevel[];
			/** Arbitrary context object for user metadata (e.g., request ID, tags) */
			context: Record<string, any>;
			/** Log Specific configuration object  */
			config: Record<string, any>;
			/** Log message fragments; to be joined or rendered later */
			message: string[];
			/** Captured stack trace info from the log emitter's callsite */
			meta: StackInfo;
			/** Runtime environment in which the log was created (node, bun, browser...) */
			env: "browser" | "node" | "deno" | "bun" | undefined;
			/** ISO string or timestamp representing log creation time */
			timestamp: string;
			/** Unique symbol to identify this log instance (for deduplication or tracking) */
			identifyer: Symbol;
		};
		clone(overrides?: Partial<{
			/** Whether this log entry has been processed and finalized */
			ready: boolean;
			/** Primary log level (e.g., "info", "error") */
			level: LogLevel;
			/** Additional log levels applied to this entry (optional) */
			subLevels: LogLevel[];
			/** Arbitrary context object for user metadata (e.g., request ID, tags) */
			context: Record<string, any>;
			/** Log Specific configuration object  */
			config: Record<string, any>;
			/** Log message fragments; to be joined or rendered later */
			message: string[];
			/** Captured stack trace info from the log emitter's callsite */
			meta: StackInfo;
			/** Runtime environment in which the log was created (node, bun, browser...) */
			env: "browser" | "node" | "deno" | "bun" | undefined;
			/** ISO string or timestamp representing log creation time */
			timestamp: string;
			/** Unique symbol to identify this log instance (for deduplication or tracking) */
			identifyer: Symbol;
		}>): any;
		patch(overrides?: Partial<{
			/** Whether this log entry has been processed and finalized */
			ready: boolean;
			/** Primary log level (e.g., "info", "error") */
			level: LogLevel;
			/** Additional log levels applied to this entry (optional) */
			subLevels: LogLevel[];
			/** Arbitrary context object for user metadata (e.g., request ID, tags) */
			context: Record<string, any>;
			/** Log Specific configuration object  */
			config: Record<string, any>;
			/** Log message fragments; to be joined or rendered later */
			message: string[];
			/** Captured stack trace info from the log emitter's callsite */
			meta: StackInfo;
			/** Runtime environment in which the log was created (node, bun, browser...) */
			env: "browser" | "node" | "deno" | "bun" | undefined;
			/** ISO string or timestamp representing log creation time */
			timestamp: string;
			/** Unique symbol to identify this log instance (for deduplication or tracking) */
			identifyer: Symbol;
		}>): any;
		describe(): Record<string, any>;
		pick<K extends "ready" | "level" | "subLevels" | "context" | "config" | "message" | "meta" | "env" | "timestamp" | "identifyer">(...keys: K[]): Pick<{
			/** Whether this log entry has been processed and finalized */
			ready: boolean;
			/** Primary log level (e.g., "info", "error") */
			level: LogLevel;
			/** Additional log levels applied to this entry (optional) */
			subLevels: LogLevel[];
			/** Arbitrary context object for user metadata (e.g., request ID, tags) */
			context: Record<string, any>;
			/** Log Specific configuration object  */
			config: Record<string, any>;
			/** Log message fragments; to be joined or rendered later */
			message: string[];
			/** Captured stack trace info from the log emitter's callsite */
			meta: StackInfo;
			/** Runtime environment in which the log was created (node, bun, browser...) */
			env: "browser" | "node" | "deno" | "bun" | undefined;
			/** ISO string or timestamp representing log creation time */
			timestamp: string;
			/** Unique symbol to identify this log instance (for deduplication or tracking) */
			identifyer: Symbol;
		}, K>;
		omit<K extends "ready" | "level" | "subLevels" | "context" | "config" | "message" | "meta" | "env" | "timestamp" | "identifyer">(...keys: K[]): Omit<{
			/** Whether this log entry has been processed and finalized */
			ready: boolean;
			/** Primary log level (e.g., "info", "error") */
			level: LogLevel;
			/** Additional log levels applied to this entry (optional) */
			subLevels: LogLevel[];
			/** Arbitrary context object for user metadata (e.g., request ID, tags) */
			context: Record<string, any>;
			/** Log Specific configuration object  */
			config: Record<string, any>;
			/** Log message fragments; to be joined or rendered later */
			message: string[];
			/** Captured stack trace info from the log emitter's callsite */
			meta: StackInfo;
			/** Runtime environment in which the log was created (node, bun, browser...) */
			env: "browser" | "node" | "deno" | "bun" | undefined;
			/** ISO string or timestamp representing log creation time */
			timestamp: string;
			/** Unique symbol to identify this log instance (for deduplication or tracking) */
			identifyer: Symbol;
		}, K>;
		pickStruct<K extends "ready" | "level" | "subLevels" | "context" | "config" | "message" | "meta" | "env" | "timestamp" | "identifyer">(...keys: K[]): Struct<Pick<{
			/** Whether this log entry has been processed and finalized */
			ready: boolean;
			/** Primary log level (e.g., "info", "error") */
			level: LogLevel;
			/** Additional log levels applied to this entry (optional) */
			subLevels: LogLevel[];
			/** Arbitrary context object for user metadata (e.g., request ID, tags) */
			context: Record<string, any>;
			/** Log Specific configuration object  */
			config: Record<string, any>;
			/** Log message fragments; to be joined or rendered later */
			message: string[];
			/** Captured stack trace info from the log emitter's callsite */
			meta: StackInfo;
			/** Runtime environment in which the log was created (node, bun, browser...) */
			env: "browser" | "node" | "deno" | "bun" | undefined;
			/** ISO string or timestamp representing log creation time */
			timestamp: string;
			/** Unique symbol to identify this log instance (for deduplication or tracking) */
			identifyer: Symbol;
		}, K>>;
	};
};
export type BusEvent = InstanceType<typeof LogInstance>;
export type BusEventHandler = InstanceType<typeof MoniTextPolicy> | ((log: BusEvent, config: typeof BusConfig) => void);
declare const BusConfig: {
	config: Record<string, any>;
	format: Record<string, any>;
};
declare const BusFullConfig: (userDefined: Partial<{
	load: BusEventHandler[];
	config: Record<string, any>;
	format: Record<string, any>;
}>) => {
	load: BusEventHandler[];
	config: Record<string, any>;
	format: Record<string, any>;
};
declare const PolicyRecord: {
	default: {
		createConfig: (userDefined: Partial<{
			apiKey: string;
			project: string;
			silence: ("info")[];
			transportInterval: number;
			transportationRetryDelay: number;
			transportMaxRetryPerTransport: number;
			transportOnFailRetryAfter: number;
		}>) => {
			apiKey: string;
			project: string;
			silence: ("info")[];
			transportInterval: number;
			transportationRetryDelay: number;
			transportMaxRetryPerTransport: number;
			transportOnFailRetryAfter: number;
		};
		createFormating: (userDefined: Partial<{
			mode: "dev" | "json" | "compact";
			info: Partial<{
				showEnv: boolean;
				showTimestamp: boolean;
				showContext: boolean;
				showConfig: boolean;
				showCallerName: boolean;
				showFileName: boolean;
				showLineNumber: boolean;
				showColumnNumber: boolean;
				showFullTrace: boolean;
				showTraceInfo: boolean;
			}>;
			warn: Partial<{
				showEnv: boolean;
				showTimestamp: boolean;
				showContext: boolean;
				showConfig: boolean;
				showCallerName: boolean;
				showFileName: boolean;
				showLineNumber: boolean;
				showColumnNumber: boolean;
				showFullTrace: boolean;
				showTraceInfo: boolean;
			}>;
			error: Partial<{
				showEnv: boolean;
				showTimestamp: boolean;
				showContext: boolean;
				showConfig: boolean;
				showCallerName: boolean;
				showFileName: boolean;
				showLineNumber: boolean;
				showColumnNumber: boolean;
				showFullTrace: boolean;
				showTraceInfo: boolean;
			}>;
			fatal: Partial<{
				showEnv: boolean;
				showTimestamp: boolean;
				showContext: boolean;
				showConfig: boolean;
				showCallerName: boolean;
				showFileName: boolean;
				showLineNumber: boolean;
				showColumnNumber: boolean;
				showFullTrace: boolean;
				showTraceInfo: boolean;
			}>;
			trace: Partial<{
				showEnv: boolean;
				showTimestamp: boolean;
				showContext: boolean;
				showConfig: boolean;
				showCallerName: boolean;
				showFileName: boolean;
				showLineNumber: boolean;
				showColumnNumber: boolean;
				showFullTrace: boolean;
				showTraceInfo: boolean;
			}>;
			profile: Partial<{
				showEnv: boolean;
				showTimestamp: boolean;
				showContext: boolean;
				showConfig: boolean;
				showCallerName: boolean;
				showFileName: boolean;
				showLineNumber: boolean;
				showColumnNumber: boolean;
				showFullTrace: boolean;
				showTraceInfo: boolean;
			}>;
			failure: Partial<{
				showEnv: boolean;
				showTimestamp: boolean;
				showContext: boolean;
				showConfig: boolean;
				showCallerName: boolean;
				showFileName: boolean;
				showLineNumber: boolean;
				showColumnNumber: boolean;
				showFullTrace: boolean;
				showTraceInfo: boolean;
			}>;
			success: Partial<{
				showEnv: boolean;
				showTimestamp: boolean;
				showContext: boolean;
				showConfig: boolean;
				showCallerName: boolean;
				showFileName: boolean;
				showLineNumber: boolean;
				showColumnNumber: boolean;
				showFullTrace: boolean;
				showTraceInfo: boolean;
			}>;
		}>) => {
			mode: "dev" | "json" | "compact";
			info: Partial<{
				showEnv: boolean;
				showTimestamp: boolean;
				showContext: boolean;
				showConfig: boolean;
				showCallerName: boolean;
				showFileName: boolean;
				showLineNumber: boolean;
				showColumnNumber: boolean;
				showFullTrace: boolean;
				showTraceInfo: boolean;
			}>;
			warn: Partial<{
				showEnv: boolean;
				showTimestamp: boolean;
				showContext: boolean;
				showConfig: boolean;
				showCallerName: boolean;
				showFileName: boolean;
				showLineNumber: boolean;
				showColumnNumber: boolean;
				showFullTrace: boolean;
				showTraceInfo: boolean;
			}>;
			error: Partial<{
				showEnv: boolean;
				showTimestamp: boolean;
				showContext: boolean;
				showConfig: boolean;
				showCallerName: boolean;
				showFileName: boolean;
				showLineNumber: boolean;
				showColumnNumber: boolean;
				showFullTrace: boolean;
				showTraceInfo: boolean;
			}>;
			fatal: Partial<{
				showEnv: boolean;
				showTimestamp: boolean;
				showContext: boolean;
				showConfig: boolean;
				showCallerName: boolean;
				showFileName: boolean;
				showLineNumber: boolean;
				showColumnNumber: boolean;
				showFullTrace: boolean;
				showTraceInfo: boolean;
			}>;
			trace: Partial<{
				showEnv: boolean;
				showTimestamp: boolean;
				showContext: boolean;
				showConfig: boolean;
				showCallerName: boolean;
				showFileName: boolean;
				showLineNumber: boolean;
				showColumnNumber: boolean;
				showFullTrace: boolean;
				showTraceInfo: boolean;
			}>;
			profile: Partial<{
				showEnv: boolean;
				showTimestamp: boolean;
				showContext: boolean;
				showConfig: boolean;
				showCallerName: boolean;
				showFileName: boolean;
				showLineNumber: boolean;
				showColumnNumber: boolean;
				showFullTrace: boolean;
				showTraceInfo: boolean;
			}>;
			failure: Partial<{
				showEnv: boolean;
				showTimestamp: boolean;
				showContext: boolean;
				showConfig: boolean;
				showCallerName: boolean;
				showFileName: boolean;
				showLineNumber: boolean;
				showColumnNumber: boolean;
				showFullTrace: boolean;
				showTraceInfo: boolean;
			}>;
			success: Partial<{
				showEnv: boolean;
				showTimestamp: boolean;
				showContext: boolean;
				showConfig: boolean;
				showCallerName: boolean;
				showFileName: boolean;
				showLineNumber: boolean;
				showColumnNumber: boolean;
				showFullTrace: boolean;
				showTraceInfo: boolean;
			}>;
		};
		policies: MoniTextPolicy[];
	};
};
/**
 * Retrieves a policy record from the `PolicyRecord` object based on the provided name.
 *
 * @param name - The key corresponding to the desired policy record in `PolicyRecord`.
 *               Must be a valid key of the `PolicyRecord` object.
 *
 * @returns The policy record associated with the provided name.
 *
 * @throws {Error} If the requested record does not exist in `PolicyRecord`.
 *                 The error message includes the requested name and a list of available keys.
 */
export declare function getPolicyRecord(name: keyof typeof PolicyRecord): {
	createConfig: (userDefined: Partial<{
		apiKey: string;
		project: string;
		silence: ("info")[];
		transportInterval: number;
		transportationRetryDelay: number;
		transportMaxRetryPerTransport: number;
		transportOnFailRetryAfter: number;
	}>) => {
		apiKey: string;
		project: string;
		silence: ("info")[];
		transportInterval: number;
		transportationRetryDelay: number;
		transportMaxRetryPerTransport: number;
		transportOnFailRetryAfter: number;
	};
	createFormating: (userDefined: Partial<{
		mode: "dev" | "json" | "compact";
		info: Partial<{
			showEnv: boolean;
			showTimestamp: boolean;
			showContext: boolean;
			showConfig: boolean;
			showCallerName: boolean;
			showFileName: boolean;
			showLineNumber: boolean;
			showColumnNumber: boolean;
			showFullTrace: boolean;
			showTraceInfo: boolean;
		}>;
		warn: Partial<{
			showEnv: boolean;
			showTimestamp: boolean;
			showContext: boolean;
			showConfig: boolean;
			showCallerName: boolean;
			showFileName: boolean;
			showLineNumber: boolean;
			showColumnNumber: boolean;
			showFullTrace: boolean;
			showTraceInfo: boolean;
		}>;
		error: Partial<{
			showEnv: boolean;
			showTimestamp: boolean;
			showContext: boolean;
			showConfig: boolean;
			showCallerName: boolean;
			showFileName: boolean;
			showLineNumber: boolean;
			showColumnNumber: boolean;
			showFullTrace: boolean;
			showTraceInfo: boolean;
		}>;
		fatal: Partial<{
			showEnv: boolean;
			showTimestamp: boolean;
			showContext: boolean;
			showConfig: boolean;
			showCallerName: boolean;
			showFileName: boolean;
			showLineNumber: boolean;
			showColumnNumber: boolean;
			showFullTrace: boolean;
			showTraceInfo: boolean;
		}>;
		trace: Partial<{
			showEnv: boolean;
			showTimestamp: boolean;
			showContext: boolean;
			showConfig: boolean;
			showCallerName: boolean;
			showFileName: boolean;
			showLineNumber: boolean;
			showColumnNumber: boolean;
			showFullTrace: boolean;
			showTraceInfo: boolean;
		}>;
		profile: Partial<{
			showEnv: boolean;
			showTimestamp: boolean;
			showContext: boolean;
			showConfig: boolean;
			showCallerName: boolean;
			showFileName: boolean;
			showLineNumber: boolean;
			showColumnNumber: boolean;
			showFullTrace: boolean;
			showTraceInfo: boolean;
		}>;
		failure: Partial<{
			showEnv: boolean;
			showTimestamp: boolean;
			showContext: boolean;
			showConfig: boolean;
			showCallerName: boolean;
			showFileName: boolean;
			showLineNumber: boolean;
			showColumnNumber: boolean;
			showFullTrace: boolean;
			showTraceInfo: boolean;
		}>;
		success: Partial<{
			showEnv: boolean;
			showTimestamp: boolean;
			showContext: boolean;
			showConfig: boolean;
			showCallerName: boolean;
			showFileName: boolean;
			showLineNumber: boolean;
			showColumnNumber: boolean;
			showFullTrace: boolean;
			showTraceInfo: boolean;
		}>;
	}>) => {
		mode: "dev" | "json" | "compact";
		info: Partial<{
			showEnv: boolean;
			showTimestamp: boolean;
			showContext: boolean;
			showConfig: boolean;
			showCallerName: boolean;
			showFileName: boolean;
			showLineNumber: boolean;
			showColumnNumber: boolean;
			showFullTrace: boolean;
			showTraceInfo: boolean;
		}>;
		warn: Partial<{
			showEnv: boolean;
			showTimestamp: boolean;
			showContext: boolean;
			showConfig: boolean;
			showCallerName: boolean;
			showFileName: boolean;
			showLineNumber: boolean;
			showColumnNumber: boolean;
			showFullTrace: boolean;
			showTraceInfo: boolean;
		}>;
		error: Partial<{
			showEnv: boolean;
			showTimestamp: boolean;
			showContext: boolean;
			showConfig: boolean;
			showCallerName: boolean;
			showFileName: boolean;
			showLineNumber: boolean;
			showColumnNumber: boolean;
			showFullTrace: boolean;
			showTraceInfo: boolean;
		}>;
		fatal: Partial<{
			showEnv: boolean;
			showTimestamp: boolean;
			showContext: boolean;
			showConfig: boolean;
			showCallerName: boolean;
			showFileName: boolean;
			showLineNumber: boolean;
			showColumnNumber: boolean;
			showFullTrace: boolean;
			showTraceInfo: boolean;
		}>;
		trace: Partial<{
			showEnv: boolean;
			showTimestamp: boolean;
			showContext: boolean;
			showConfig: boolean;
			showCallerName: boolean;
			showFileName: boolean;
			showLineNumber: boolean;
			showColumnNumber: boolean;
			showFullTrace: boolean;
			showTraceInfo: boolean;
		}>;
		profile: Partial<{
			showEnv: boolean;
			showTimestamp: boolean;
			showContext: boolean;
			showConfig: boolean;
			showCallerName: boolean;
			showFileName: boolean;
			showLineNumber: boolean;
			showColumnNumber: boolean;
			showFullTrace: boolean;
			showTraceInfo: boolean;
		}>;
		failure: Partial<{
			showEnv: boolean;
			showTimestamp: boolean;
			showContext: boolean;
			showConfig: boolean;
			showCallerName: boolean;
			showFileName: boolean;
			showLineNumber: boolean;
			showColumnNumber: boolean;
			showFullTrace: boolean;
			showTraceInfo: boolean;
		}>;
		success: Partial<{
			showEnv: boolean;
			showTimestamp: boolean;
			showContext: boolean;
			showConfig: boolean;
			showCallerName: boolean;
			showFileName: boolean;
			showLineNumber: boolean;
			showColumnNumber: boolean;
			showFullTrace: boolean;
			showTraceInfo: boolean;
		}>;
	};
	policies: MoniTextPolicy[];
};
declare function isAsyncFunction(fn: Function): boolean;
declare function isNumber(num: number): boolean;
declare function isPositiveNumber(num: number): boolean;
declare function isNegativeNumber(num: number): boolean;
declare function isObject(value: unknown): value is Record<string, unknown>;
declare function isValidDate(input: unknown): input is Date;
export type TypeKind = "string" | "number" | "boolean" | "array" | "object" | "function" | "null" | "undefined" | "unknown";
declare function resolveType(value: unknown): TypeKind;
declare function convertTime(time: number): {
	hours: number;
	minutes: number;
	seconds: number;
	milliseconds: number;
};
declare function writeTimeString(data: ReturnType<typeof convertTime>): string;
declare function parseDate(input: unknown): Date | null;
export type ConfigKeyValues = string | number | boolean | null | undefined | unknown[] | Record<string, any> | ((...args: any[]) => any) | ((...args: any[]) => Promise<any>);
declare class Config<U extends Record<string, ConfigKeyValues>> {
	private baseConfig;
	private overrides;
	constructor(config: U);
	/**
	 * Merge user-defined config values.
	 * @param userDefined - Partial configuration
	 * @param deep - Whether to merge nested objects deeply
	 */
	merge(userDefined: Partial<U>, deep?: boolean): this;
	toObject(): U;
	toString(): string;
	get<K extends keyof U>(key: K): U[K];
}
declare function createConfigResolver<U extends Record<string, ConfigKeyValues>>(conf: Config<U>, validate?: (config: Partial<U>) => void): (userDefined: Partial<U>) => U;
declare function extractKeys<U extends object>(target: U, ...keys: (keyof U)[]): Pick<U, keyof U>;
declare class MoniTextEventBus {
	private config;
	/**
	 * List of functions that are called on every log, regardless of level.
	 */
	private subscribers;
	/**
	 * Handlers organized by log level. Each level maps to an array of functions.
	 */
	private levelHandlers;
	/**
	 * Creates a new MoniTextServer.
	 *
	 * @param config - Configuration object passed to all handlers and plugins.
	 */
	constructor(config: typeof BusConfig);
	/**
	 * Handles a log entry by executing all level-specific and global subscribers.
	 *
	 * @param log - The log entry to handle.
	 */
	handle(log: BusEvent): Promise<void>;
	/**
	 * Subscribes a function to all log events.
	 *
	 * @param fn - The function to subscribe.
	 */
	subscribe(fn: (log: BusEvent, config: typeof BusConfig) => void): void;
	/**
	 * Registers a function to handle logs of a specific level (e.g., "warn", "info").
	 *
	 * @param level - The log level to handle.
	 * @param fn - The handler function for that level.
	 */
	on(level: string, fn: (log: BusEvent, config: unknown) => void): void;
}
/**
 * Represents a successful result.
 *
 * @template T The type of the value returned on success.
 */
export interface MonitextSuccess<T> {
	ok: true;
	value: T;
	error?: never;
}
/**
 * Represents a failed result.
 */
export interface MonitextFailure {
	ok: false;
	value?: never;
	error: Error;
}
declare class MonitextResult<T> {
	/**
	 * Indicates whether the operation succeeded.
	 */
	readonly ok: boolean;
	/**
	 * The value returned on success.
	 * This is only defined if `ok` is `true`.
	 */
	readonly value?: T;
	/**
	 * The error returned on failure.
	 * This is only defined if `ok` is `false`.
	 */
	readonly error?: Error;
	/**
	 * Constructs a new MonitextResult instance.
	 *
	 * @param ok - Whether the result is a success (`true`) or failure (`false`).
	 * @param value - The value returned if the result is successful.
	 * @param error - The error object if the result is a failure.
	 * @private
	 */
	private constructor();
	/**
	 * Creates a successful result.
	 *
	 * @param value - The value of the successful result.
	 * @returns A `MonitextResult` with `ok: true` and the provided value.
	 */
	static ok<T>(value: T): MonitextSuccess<T>;
	/**
	 * Creates a failed result.
	 *
	 * @param error - The error that caused the failure.
	 * @returns A `MonitextResult` with `ok: false` and the provided error.
	 */
	static fail<T>(error: Error): MonitextFailure;
}
export type ProfilerParam = {
	expectDuration: number;
	forAverageOf?: number;
};
export type CompactLogFn = (...args: CompactLogFnArgument) => InstanceType<typeof LogInstance>;
export type CompactLogFnArgument = [
	messsage: string,
	param?: {
		context?: {};
		config?: {};
	}
];
export type t = Record<string, unknown>;
export type b = Record<string, unknown>;
export type ChainableLogFn = (...message: string[]) => {
	config: (v: b) => {
		context: (v: t) => void;
	};
	context: (v: t) => {
		config: (v: b) => void;
	};
};
export type LoggingMode = "compact" | "chainable";
export type ModeToLogger<T extends LoggingMode> = T extends "compact" ? CompactLogFn : T extends "chainable" ? ChainableLogFn : never;
declare class MonitextLoggingInterface<M extends LoggingMode = "compact" | "chainable"> {
	protected bus: MoniTextEventBus;
	mode: M;
	info: ModeToLogger<M>;
	warn: ModeToLogger<M>;
	error: ModeToLogger<M>;
	fatal: ModeToLogger<M>;
	success: ModeToLogger<M>;
	failure: ModeToLogger<M>;
	private commonLevel;
	constructor(bus: MoniTextEventBus, mode: M);
	private createCompactLogEmitter;
	private createChainableLogEmitter;
	profile<U, T extends any[]>(fn: (...args: T) => U | Promise<U>, param: ProfilerParam): ((...args: T) => Promise<MonitextResult<U>>) | ((...args: T) => MonitextResult<U>);
	trace<U, T extends any[]>(fn: (...args: T) => U | Promise<U>, _param: ProfilerParam): ((args: T) => Promise<{
		exec: any[];
	}>) | ((args: T) => {
		exec: any[];
	});
}
declare const cols: {
	bold: (...message: string[]) => string;
	reset: (...message: string[]) => string;
	dim: (...message: string[]) => string;
	italic: (...message: string[]) => string;
	underline: (...message: string[]) => string;
	inverse: (...message: string[]) => string;
	hidden: (...message: string[]) => string;
	strikethrough: (...message: string[]) => string;
	black: (...message: string[]) => string;
	red: (...message: string[]) => string;
	green: (...message: string[]) => string;
	yellow: (...message: string[]) => string;
	blue: (...message: string[]) => string;
	magenta: (...message: string[]) => string;
	cyan: (...message: string[]) => string;
	white: (...message: string[]) => string;
	gray: (...message: string[]) => string;
	grey: (...message: string[]) => string;
	blackBright: (...message: string[]) => string;
	redBright: (...message: string[]) => string;
	greenBright: (...message: string[]) => string;
	yellowBright: (...message: string[]) => string;
	blueBright: (...message: string[]) => string;
	magentaBright: (...message: string[]) => string;
	cyanBright: (...message: string[]) => string;
	whiteBright: (...message: string[]) => string;
	bgBlack: (...message: string[]) => string;
	bgRed: (...message: string[]) => string;
	bgGreen: (...message: string[]) => string;
	bgYellow: (...message: string[]) => string;
	bgBlue: (...message: string[]) => string;
	bgMagenta: (...message: string[]) => string;
	bgCyan: (...message: string[]) => string;
	bgWhite: (...message: string[]) => string;
	bgGray: (...message: string[]) => string;
	bgGrey: (...message: string[]) => string;
	bgBlackBright: (...message: string[]) => string;
	bgRedBright: (...message: string[]) => string;
	bgGreenBright: (...message: string[]) => string;
	bgYellowBright: (...message: string[]) => string;
	bgBlueBright: (...message: string[]) => string;
	bgMagentaBright: (...message: string[]) => string;
	bgCyanBright: (...message: string[]) => string;
	bgWhiteBright: (...message: string[]) => string;
};
declare function hr(title?: string, opts?: {
	char?: string;
	color?: (text: string) => string;
	padding?: number;
}): string;
declare function writeColoredString(fn: (h: typeof hr, col: typeof cols, push: (str: string | string[]) => void, join: (str: string) => void) => void, env?: "browser" | "node" | "deno" | "bun" | undefined): string[];
export declare const utils: {
	lookUpInStack: typeof lookUpInStack;
	parseDate: typeof parseDate;
	extractKeys: typeof extractKeys;
	check: typeof check;
	convertTime: typeof convertTime;
	writeTimeString: typeof writeTimeString;
};
export declare const tools: {
	createStructFromShape: typeof createStructFromShape;
	createConfigResolver: typeof createConfigResolver;
	writeColoredString: typeof writeColoredString;
	PolicyInstance: {
		new (raw?: Partial<{
			install: (bus: MoniTextEventBus, config: typeof BusConfig) => void;
		}> | undefined): {
			validate(): void;
			"__#1@#raw": {
				install: (bus: MoniTextEventBus, config: typeof BusConfig) => void;
			};
			_struct: {
				install: (bus: MoniTextEventBus, config: typeof BusConfig) => void;
			};
			toObject(): {
				install: (bus: MoniTextEventBus, config: typeof BusConfig) => void;
			};
			clone(overrides?: Partial<{
				install: (bus: MoniTextEventBus, config: typeof BusConfig) => void;
			}>): any;
			patch(overrides?: Partial<{
				install: (bus: MoniTextEventBus, config: typeof BusConfig) => void;
			}>): any;
			describe(): Record<string, any>;
			pick<K extends "install">(...keys: K[]): Pick<{
				install: (bus: MoniTextEventBus, config: typeof BusConfig) => void;
			}, K>;
			omit<K extends "install">(...keys: K[]): Omit<{
				install: (bus: MoniTextEventBus, config: typeof BusConfig) => void;
			}, K>;
			pickStruct<K extends "install">(...keys: K[]): Struct<Pick<{
				install: (bus: MoniTextEventBus, config: typeof BusConfig) => void;
			}, K>>;
		};
	};
	LogInstance: {
		new (raw?: Partial<{
			ready: boolean;
			level: LogLevel;
			subLevels: LogLevel[];
			context: Record<string, any>;
			config: Record<string, any>;
			message: string[];
			meta: StackInfo;
			env: "browser" | "node" | "deno" | "bun" | undefined;
			timestamp: string;
			identifyer: Symbol;
		}> | undefined): {
			validate(): void;
			"__#1@#raw": {
				ready: boolean;
				level: LogLevel;
				subLevels: LogLevel[];
				context: Record<string, any>;
				config: Record<string, any>;
				message: string[];
				meta: StackInfo;
				env: "browser" | "node" | "deno" | "bun" | undefined;
				timestamp: string;
				identifyer: Symbol;
			};
			_struct: {
				ready: boolean;
				level: LogLevel;
				subLevels: LogLevel[];
				context: Record<string, any>;
				config: Record<string, any>;
				message: string[];
				meta: StackInfo;
				env: "browser" | "node" | "deno" | "bun" | undefined;
				timestamp: string;
				identifyer: Symbol;
			};
			toObject(): {
				ready: boolean;
				level: LogLevel;
				subLevels: LogLevel[];
				context: Record<string, any>;
				config: Record<string, any>;
				message: string[];
				meta: StackInfo;
				env: "browser" | "node" | "deno" | "bun" | undefined;
				timestamp: string;
				identifyer: Symbol;
			};
			clone(overrides?: Partial<{
				ready: boolean;
				level: LogLevel;
				subLevels: LogLevel[];
				context: Record<string, any>;
				config: Record<string, any>;
				message: string[];
				meta: StackInfo;
				env: "browser" | "node" | "deno" | "bun" | undefined;
				timestamp: string;
				identifyer: Symbol;
			}>): any;
			patch(overrides?: Partial<{
				ready: boolean;
				level: LogLevel;
				subLevels: LogLevel[];
				context: Record<string, any>;
				config: Record<string, any>;
				message: string[];
				meta: StackInfo;
				env: "browser" | "node" | "deno" | "bun" | undefined;
				timestamp: string;
				identifyer: Symbol;
			}>): any;
			describe(): Record<string, any>;
			pick<K extends "ready" | "level" | "subLevels" | "context" | "config" | "message" | "meta" | "env" | "timestamp" | "identifyer">(...keys: K[]): Pick<{
				ready: boolean;
				level: LogLevel;
				subLevels: LogLevel[];
				context: Record<string, any>;
				config: Record<string, any>;
				message: string[];
				meta: StackInfo;
				env: "browser" | "node" | "deno" | "bun" | undefined;
				timestamp: string;
				identifyer: Symbol;
			}, K>;
			omit<K extends "ready" | "level" | "subLevels" | "context" | "config" | "message" | "meta" | "env" | "timestamp" | "identifyer">(...keys: K[]): Omit<{
				ready: boolean;
				level: LogLevel;
				subLevels: LogLevel[];
				context: Record<string, any>;
				config: Record<string, any>;
				message: string[];
				meta: StackInfo;
				env: "browser" | "node" | "deno" | "bun" | undefined;
				timestamp: string;
				identifyer: Symbol;
			}, K>;
			pickStruct<K extends "ready" | "level" | "subLevels" | "context" | "config" | "message" | "meta" | "env" | "timestamp" | "identifyer">(...keys: K[]): Struct<Pick<{
				ready: boolean;
				level: LogLevel;
				subLevels: LogLevel[];
				context: Record<string, any>;
				config: Record<string, any>;
				message: string[];
				meta: StackInfo;
				env: "browser" | "node" | "deno" | "bun" | undefined;
				timestamp: string;
				identifyer: Symbol;
			}, K>>;
		};
	};
	Config: typeof Config;
};
export declare function createRuntime(configuration: ReturnType<typeof BusFullConfig>): {
	mtxt: MonitextLoggingInterface<"compact">;
	monitext: MonitextLoggingInterface<"chainable">;
};

declare namespace check {
	export { isAsyncFunction, isNegativeNumber, isNumber, isObject, isPositiveNumber, isValidDate, resolveType };
}

export {};
